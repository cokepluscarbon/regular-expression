#02-字符组[ ]

假设搜索文本： **like** 和 **lake** ,由于like和lake只相差一个单词，我们不必要使用两个正则表达式匹配，而使用一个
 **l[ai]ke** 就可以搜索文本中所有出现的like和lake了。同时，我们也可以使用 **like|lake** 来进行匹配，效果是一样的，不过
 **l[ai]ke** 更简洁，不是吗？
 
    正则：l[ai]ke
    // l[ai]ke中的[ai]表示，匹配ai中的一个
    // l[ai]ke则表示，先匹配l，再匹配a或i，最后匹配ke
  
为了使正则表达式更加的形象生动，介绍一款在线的正则表达式图形化工具: http://www.regexper.com/

使用regexper图形化 **l[ai]ke** 的结果为：

![regexper生成图形化正则表达式](/images/02-01.jpg)

字符组 **[ ]** 里面可以放若干个字符，它表示匹配若干个字符中的一个（如上图中one of之意），例如

    正则: c[aou]t
    // 表示，先匹配c，再匹配a、o、u中的一个，最后匹配t
    // 匹配cat、cot、cut
    
