#14.环视

##14.1 格式化数字
  
  有一串数字，例如： **123456789** ，为了更利于阅读，我们想将它格式化成： **123,456,789** 从右边起每三位数字加一个逗号这种格式。使用正则，我们应该怎么处理呢？
  
```
格式化前：123456789
格式化后：123,456,789
```
  
  在目前看来，之前提到的正则，似乎很难进行处理。我们知道，一般正则是从左到右进行匹配的，而例子中数字串是从右往左每隔三位数字添加一个逗号。
  我们急需一种可以从右向左匹配的方法。而 **环视** 就是我们需要的这个神奇方法。

##14.2 环视

  环视分为：**顺序环视** 和 **逆序环视** 。

> **顺序环视** ：从表达式左边到右边查看文本，尝试匹配子表达式，如果能够匹配，则返回匹配成功信息。

  **顺序环视** 又分为 **肯定型顺序环视** 和 **否定型顺序环视** ，分别用<code>(?=pattern)</code>和表示<code>(?!pattern)</code>，例如：
  
```
(?=abc)  // 从左往右查找文本，如果右边出现abc，则匹配成功
(?!abc)  // 从左往右查找文本，如果右边不出现abc，则匹配成功
```

  需要注意很重要的一点， **环视并不占用任何文本，它只匹配一个位置** ，像<code>abc(?=xyz)</code>这里的环视并不占用任何文本，它只匹配abc跟xyz中间的一个位置。
  
> **逆序环视** ：逆序环视跟顺序环视刚好相反

  **逆序环视** 也分为 **肯定型逆序环视** 和 **否定性逆序环视** ，分别用<code>(?<=pattern)</code>和表示<code>(?<!pattern)</code>，例如：
  
```
(?<=abc)  // 从右往左查找文本，如果左边出现abc，则匹配成功
(?<!abc)  // 从右往左查找文本，如果左边不出现abc，则匹配成功
```

  举个例子：
  
```
正则：(?<=abc)(?=xyz)
分析：正则用了顺序环视和逆序环视，匹配左边有abc同时右边有xyz的位置。注意匹配的是位置
      如果，我们使用Java的replaceAll方法
      replaceAll("(?<=abc)(?=xyz)", "&&"), 结果就是在abc和xyz中间插入&&,结果为：abc&&xyz
注意：在这里，两个环视对调位置是不会影响效果的，也就是说
      (?<=abc)(?=xyz)  和  (?=xyz)(?<=abc)的效果是一样的
```

##14.3 解决格式化数字的问题

  虽然解决了环视的问题，要解决数字的格式化还是有是需要点技巧的。看数字格式化前后的效果：

```
格式化前：123456789
格式化后：123,456,789
```
  * 从右往左，每三个数字前添加一个逗号；
  * 虽然^后面有三个数字，但是1前面是没有逗号的。

  如果按照这个思路写正则，或许还有些困难，我们不坊换个思路：
  
  * 从右往左，只要有位置距离最右边的位数为3的倍数，则在前面添加一个逗号；
  * 虽然^后面有三个数字，但是1前面是没有逗号的。
  
  现在，让我们来step by step写出答案：

******

> 连续三个数字：\d{3}

> 距离最右边为三的倍数：(\d{3})+$

> 使用环视匹配位置：(?=(\d{3})+$)

> 使用逆序环视解决第一个位置不能有逗号的问题：(?<=\d)(?=(\d{3})+$)

******

  使用Java来实现数字格式化：
```java
String text = "123456789";
  	
String result = text.replaceAll("(?<=\\d)(?=(\\d{3})+$)", ",");

System.out.println(result); // 输出：123,456,789
```
