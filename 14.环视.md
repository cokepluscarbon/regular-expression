#14.环视

##14.1 格式化数字
  
  有一串数字，例如： **123456789** ，为了更利于阅读，我们想将它格式化成： **123,456,789** 从右边起每三位数字加一个逗号这种格式。使用正则，我们应该怎么处理呢？
  
```
格式化前：123456789
格式化后：123,456,789
```
  
  在目前看来，之前提到的正则，似乎很难进行处理。我们知道，一般正则是从左到右进行匹配的，而例子中数字串是从右往左每隔三位数字添加一个逗号。
  我们急需一种可以从右向左匹配的方法。而 **环视** 就是我们需要的这个神奇方法。

##14.2 环视

  环视分为：**顺序环视** 和 **逆序环视** 。

> **顺序环视** ：从表达式左边到右边查看文本，尝试匹配子表达式，如果能够匹配，则返回匹配成功信息。

  **顺序环视** 又分为 **肯定型顺序环视** 和 **否定型顺序环视** ，分别用<code>(?=pattern)</code>和表示<code>(?!pattern)</code>，例如：
  
```
(?=abc)  // 从左往右查找文本，如果右边出现abc，则匹配成功
(?!abc)  // 从左往右查找文本，如果右边不出现abc，则匹配成功
```

  需要注意很重要的一点， **环视并不占用任何文本，它只匹配一个位置** ，像<code>abc(?=xyz)</code>这里的环视并不占用任何文本，它只匹配abc跟xyz中间的一个位置。
  
> **逆序环视** ：逆序环视跟顺序环视刚好相反

  **逆序环视** 也分为 **肯定型逆序环视** 和 **否定性逆序环视** ，分别用<code>(?<=pattern)</code>和表示<code>(?<!pattern)</code>，例如：
  
```
(?<=abc)  // 从右往左查找文本，如果左边出现abc，则匹配成功
(?<!abc)  // 从右往左查找文本，如果左边不出现abc，则匹配成功
```

  举个例子：
  
```
正则：(?<=abc)(?=xyz)
分析：正则用了顺序环视和逆序环视，匹配左边有abc同时右边有xyz的位置。注意匹配的是位置
      如果，我们使用Java的replaceAll方法
      replaceAll("(?<=abc)(?=xyz)", "&&"), 结果就是在abc和xyz中间插入&&,结果为：abc&&xyz
注意：在这里，两个环视对调位置是不会影响效果的，也就是说
      (?<=abc)(?=xyz)  和  (?=xyz)(?<=abc)的效果是一样的
```



  
  
